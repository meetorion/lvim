require("lspconfig").clangd.setup({
    capabilities = {
        offsetEncoding = { "utf-16" }
    }
})

lvim.format_on_save = true
-- lvim.lsp.diagnostics.virtual_text = true
vim.diagnostic.config({
    virtual_text = true
})

lvim.builtin.treesitter.highlight.enable = true

-- auto install treesitter parsers
lvim.builtin.treesitter.ensure_installed = { "cpp", "c" }

-- -- Additional Plugins
table.insert(lvim.plugins, {
    {
        "p00f/clangd_extensions.nvim",
        after = "mason-lspconfig.nvim", -- make sure to load after mason-lspconfig
        config = function()
            local provider = "clangd"
            local clangd_flags = {
                -- 在后台自动分析文件（基于complie_commands)
                "--compile-commands-dir=build",
                "--background-index",
                "--completion-style=detailed",
                -- 同时开启的任务数量
                "--all-scopes-completion=true",
                "--recovery-ast",
                "--suggest-missing-includes",
                -- 告诉clangd用那个clang进行编译，路径参考which clang++的路径
                "--query-driver=/usr/locla/bin/clang++,/usr/bin/g++",
                "--clang-tidy",
                -- 全局补全（会自动补充头文件）
                "--all-scopes-completion",
                "--cross-file-rename",
                -- 更详细的补全内容
                "--completion-style=detailed",
                "--function-arg-placeholders=false",
                -- 补充头文件的形式
                "--header-insertion=never",
                -- pch优化的位置
                "--pch-storage=memory",
                "--offset-encoding=utf-16",
                "-j=12",
            }

            local custom_on_attach = function(client, bufnr)
                require("lvim.lsp").common_on_attach(client, bufnr)
                require("clangd_extensions.inlay_hints").setup_autocmd()
                require("clangd_extensions.inlay_hints").set_inlay_hints()
            end


            local custom_on_init = function(client, bufnr)
                require("lvim.lsp").common_on_init(client, bufnr)
                require("clangd_extensions.config").setup {}
                require("clangd_extensions.ast").init()
                vim.cmd [[
              command ClangdToggleInlayHints lua require('clangd_extensions.inlay_hints').toggle_inlay_hints()
              command -range ClangdAST lua require('clangd_extensions.ast').display_ast(<line1>, <line2>)
              command ClangdTypeHierarchy lua require('clangd_extensions.type_hierarchy').show_hierarchy()
              command ClangdSymbolInfo lua require('clangd_extensions.symbol_info').show_symbol_info()
              command -nargs=? -complete=customlist,s:memuse_compl ClangdMemoryUsage lua require('clangd_extensions.memory_usage').show_memory_usage('<args>' == 'expand_preamble')
              ]]
            end

            local opts = {
                cmd = { provider, unpack(clangd_flags) },
                on_attach = custom_on_attach,
                on_init = custom_on_init,
            }

            require("lvim.lsp.manager").setup("clangd", opts)
        end
    },
})

vim.list_extend(lvim.lsp.automatic_configuration.skipped_servers, { "clangd" })

-- some settings can only passed as commandline flags, see `clangd --help`
local clangd_flags = {
    "--background-index",
    "--fallback-style=Google",
    "--all-scopes-completion",
    "--clang-tidy",
    "--log=error",
    "--suggest-missing-includes",
    "--cross-file-rename",
    "--completion-style=detailed",
    "--pch-storage=memory",     -- could also be disk
    "--folding-ranges",
    "--enable-config",          -- clangd 11+ supports reading from .clangd configuration file
    "--offset-encoding=utf-16", --temporary fix for null-ls
    -- "--limit-references=1000",
    -- "--limit-resutls=1000",
    -- "--malloc-trim",
    -- "--clang-tidy-checks=-*,llvm-*,clang-analyzer-*,modernize-*,-modernize-use-trailing-return-type",
    -- "--header-insertion=never",
    -- "--query-driver=<list-of-white-listed-complers>"
}

local provider = "clangd"

local custom_on_attach = function(client, bufnr)
    require("lvim.lsp").common_on_attach(client, bufnr)

    local opts = { noremap = true, silent = true, buffer = bufnr }
    vim.keymap.set("n", "<leader>lh", "<cmd>ClangdSwitchSourceHeader<cr>", opts)
    vim.keymap.set("x", "<leader>lA", "<cmd>ClangdAST<cr>", opts)
    vim.keymap.set("n", "<leader>lH", "<cmd>ClangdTypeHierarchy<cr>", opts)
    vim.keymap.set("n", "<leader>lt", "<cmd>ClangdSymbolInfo<cr>", opts)
    vim.keymap.set("n", "<leader>lm", "<cmd>ClangdMemoryUsage<cr>", opts)

    require("clangd_extensions.inlay_hints").setup_autocmd()
    require("clangd_extensions.inlay_hints").set_inlay_hints()
end

local status_ok, project_config = pcall(require, "rhel.clangd_wrl")
if status_ok then
    clangd_flags = vim.tbl_deep_extend("keep", project_config, clangd_flags)
end

local custom_on_init = function(client, bufnr)
    require("lvim.lsp").common_on_init(client, bufnr)
    require("clangd_extensions.config").setup {}
    require("clangd_extensions.ast").init()
    vim.cmd [[
  command ClangdToggleInlayHints lua require('clangd_extensions.inlay_hints').toggle_inlay_hints()
  command -range ClangdAST lua require('clangd_extensions.ast').display_ast(<line1>, <line2>)
  command ClangdTypeHierarchy lua require('clangd_extensions.type_hierarchy').show_hierarchy()
  command ClangdSymbolInfo lua require('clangd_extensions.symbol_info').show_symbol_info()
  command -nargs=? -complete=customlist,s:memuse_compl ClangdMemoryUsage lua require('clangd_extensions.memory_usage').show_memory_usage('<args>' == 'expand_preamble')
  ]]
end

local opts = {
    cmd = { provider, unpack(clangd_flags) },
    on_attach = custom_on_attach,
    on_init = custom_on_init,
}

require("lvim.lsp.manager").setup("clangd", opts)



-- 引入dap模块
local dap = require('dap')
dap.adapters.lldb = {
    type = "executable",
    --[[
    配置adapter可执行文件路径, 注意这里的lldb-vscode需要用自己的实际路径
    这里的lldb-vscode可执行文件从我的路径可以看出，实际上是从llvm中编译出来的。
    后面会一步一步解释怎么编译lldb-vscode以及lldb-server
]]
    command = "/home/leejoy/Git/llvm-project/bin/lldb-vscode",
    -- 这里的name对应下面configurations中的type
    name = "lldb",
}
local get_args = function()
    -- 获取输入命令行参数
    local cmd_args = vim.fn.input('CommandLine Args:')
    local params = {}
    -- 定义分隔符(%s在lua内表示任何空白符号)
    local sep = "%s"
    for param in string.gmatch(cmd_args, "[^%s]+") do
        table.insert(params, param)
    end
    return params
end;
local function get_executable_from_cmake(path)
    -- 使用awk获取CMakeLists.txt文件内要生成的可执行文件的名字
    -- 有需求可以自己改成别的
    local get_executable =
        'awk "BEGIN {IGNORECASE=1} /add_executable\\s*\\([^)]+\\)/ {match(\\$0, /\\(([^\\)]+)\\)/,m);match(m[1], /([A-Za-z_]+)/, n);printf(\\"%s\\", n[1]);}" '
        .. path .. "CMakeLists.txt"
    return vim.fn.system(get_executable)
end
dap.configurations.cpp = {
    {
        name = "Launch file",
        type = "lldb",
        request = "launch",
        program = function()
            local current_path = vim.fn.getcwd() .. "/"
            -- 使用find命令找到Makefile或者makefile
            local fd_make = string.format('find %s -maxdepth 1 -name [m\\|M]akefile', current_path)
            local fd_make_result = vim.fn.system(fd_make)
            if (fd_make_result ~= "")
            then
                local mkf = vim.fn.system(fd_make)
                -- 使用awk默认提取Makefile(makefile)中第一个的将要生成的可执行文件名称
                -- 有需求可以自己改成别的
                local cmd = 'awk "\\$0 ~ /:/ { match(\\$1, \\"([A-Za-z_]+)\\", m); printf(\\"%s\\", m[1]); exit; }" ' ..
                    mkf
                local exe = vim.fn.system(cmd)
                -- 执行make命令
                -- Makefile里面需要设置CXXFLAGS变量哦~
                if (os.execute('make CXXFLAGS="-g"'))
                then
                    return current_path .. exe
                end
            end
            -- 查找CMakeLists.txt文件
            local fd_cmake = string.format("find %s -name CMakeLists.txt -type f", current_path)
            local fd_cmake_result = vim.fn.system(fd_cmake)
            if (fd_cmake_result == "")
            then
                return vim.fn.input("Path to executable: ", current_path, "file")
            end
            -- 查找build文件夹
            local fd_build = string.format("find %s -name build -type d", current_path)
            local fd_build_result = vim.fn.system(fd_build)
            if (fd_build_result == "")
            then
                -- 不存在则创建build文件夹
                if (not os.execute(string.format('mkdir -p %sbuild', current_path)))
                then
                    return vim.fn.input("Path to executable: ", current_path, "file")
                end
            end
            local cmd = 'cd ' .. current_path .. "build && cmake .. -DCMAKE_BUILD_TYPE=Debug"
            -- 开始构建项目
            print("Building The Project...")
            vim.fn.system(cmd)
            local exec = get_executable_from_cmake(current_path)
            local make = 'cd ' .. current_path .. 'build && make'
            local res = vim.fn.system(make)
            if (exec == "" or res == "")
            then
                return vim.fn.input("Path to executable: ", current_path, "file")
            end
            return current_path .. "build/" .. exec
        end,
        cwd = "${workspaceFolder}",
        stopOnEntry = false,
        args = get_args,
    },
}
dap.configurations.c = dap.configurations.cpp
